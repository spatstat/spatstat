\documentclass[10pt]{article}
\usepackage{graphicx}
\usepackage{Sweave}
\usepackage{bm}
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry} 

% \VignetteIndexEntry{Guide to Function Objects}

% $Revision: 1.67 $ $Date: 2023/05/17 01:10:53 $

\newcommand{\pkg}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\link}[1]{#1}
\newcommand{\R}{{\sf R}}
\newcommand{\spst}{\pkg{spatstat}}
\newcommand{\Spst}{\pkg{Spatstat}}

\newcommand{\fv}{\texttt{"fv"}}
\newcommand{\env}{\texttt{"envelope"}}
\newcommand{\obj}[1]{object of class {#1}}
\newcommand{\objs}[1]{objects of class {#1}}
\newcommand{\objsfvenv}{\objs\fv{} and \env}

\newcommand{\fun}[1]{\texttt{#1}}
\newcommand{\class}[1]{\texttt{"{#1}"}}

\newcommand{\Kfun}{$K$-function}
\newcommand{\Lfun}{$L$-function}
\newcommand{\pois}[1]{{#1}_{\mbox{\scriptsize pois}}}
\newcommand{\isoest}[1]{\widehat{#1}_{\mbox{\scriptsize iso}}}

\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\eqref}[1]{(\ref{#1})}

\begin{document}
\bibliographystyle{plain}

<<echo=FALSE,results=hide>>=
library(spatstat)
x <- read.dcf(file = system.file("DESCRIPTION", package = "spatstat"),
              fields = c("Version", "Date"))
sversion <- as.character(x[,"Version"])
sdate    <- as.character(x[,"Date"])
options(useFancyQuotes=FALSE)
setmargins <- function(...) {
  options(SweaveHooks=list(fig=function() par(mar=c(...)+0.1)))
}
@ 
<<echo=FALSE,results=hide,fig=FALSE>>=
options(SweaveHooks=list(fig=function() par(mar=c(5,4,2,4)+0.1)))
options(width=100)
@ 
\SweaveOpts{eps=TRUE}
\setkeys{Gin}{width=0.5\textwidth}

\title{A guide to function objects (class \fv\ and \env)}
\author{Adrian Baddeley, Rolf Turner and Ege Rubak}
\date{\today}
\maketitle

\thispagestyle{empty}

\begin{abstract}
  This vignette explains how to use and manipulate \objsfvenv.
  
  \framebox{\textbf{This vignette is under development!}}
\end{abstract}


\setcounter{tocdepth}{1}
\tableofcontents

\newpage
\section{Introduction}

\subsection{Functional summary statistics}

An \obj\fv\ (`function value table') is a
convenient way of storing several different
estimates of the same function. 

It is common practice to summarise a spatial point pattern dataset
using a summary function, such as Ripley's \Kfun\ $K(r)$, rather than a 
single numerical summary value. 
Typically, an empirical estimate of the function, obtained from the data,
will be compared with the `theoretical' version of the function
that would be expected if the point pattern was completely random.
There may be several different empirical estimates of the function,
based on different estimation techniques, and we also want to compare
these estimates with one another.

The \spst{} family of packages makes it very easy to
compute and handle multiple versions of a summary function.
Taking the Finnish Pines data \texttt{finpines} as an example,
we can compute and plot estimates of Ripley's \Kfun\ by typing

<<>>=
K <- Kest(finpines)
@ 

<<K,fig=TRUE>>=
plot(K)
@ 

The plot shows several curves, which
represent the different empirical estimates of the \Kfun\
(namely the 
isotropic correction $\widehat K_{\mbox{\scriptsize iso}}(r)$,
translation correction $\widehat K_{\mbox{\scriptsize trans}}(r)$,
and border correction $\widehat K_{\mbox{\scriptsize bord}}(r)$)
and also the theoretical value $K_{\mbox{\scriptsize pois}}(r)$
that would be expected if the point pattern was completely random. 
All these functions are plotted against the distance argument $r$.

The object \texttt{K} 
belongs to class \fv{} (``function value table'').
It is a data frame
(that is, it also belongs to the class \class{data.frame})
with attributes giving extra information such as the 
recommended way of plotting the function.
One column of the data frame contains evenly spaced values of
the distance argument $r$, while the other columns contain 
estimates of the value of the function, or the theoretical value
of the function under CSR, corresponding to these distance values.

More information is given by the print method \texttt{print.fv:}
<<>>=
  K
@ 
This indicates that the columns in the
data frame are named \texttt{r}, \texttt{theo}, \texttt{border},
\texttt{trans}, and \texttt{iso}, and explains their contents. 
For example, 
the column \texttt{iso} contains estimates of the \Kfun{} using the 
isotropic edge correction.
This column is labelled in the plot by the \R\ expression
\texttt{hat(K)[iso](r)} which is rendered 
as the mathematical notation $\widehat K_{\mbox{\scriptsize iso}}(r)$.

The function argument in an \class{fv} object is usually,
but not always, called \texttt{r}. (Counterexamples include
\fun{transect.im} which has function argument \texttt{t}.)

The command \texttt{plot(K)} is dispatched to the method
\texttt{plot.fv} to generate the graphic shown above. The plot method
uses the auxiliary information contained in \texttt{K} to 
attach meaningful labels to the graphic. 

Stripping off the auxiliary information we can inspect the
data frame itself:
<<>>=
head(as.data.frame(K))
@ 


This vignette explains how to plot, manipulate and create objects of 
class \fv.

\subsection{Simulation envelopes}

Simulation envelopes of summary functions
are often used to assess statistical significance
in early stages of analysis. The \spst{} command \texttt{envelope}
generates simulation envelopes of a summary function:
<<results=hide>>=
E <- envelope(finpines, Kest, nsim=39)
@ 
<<E,fig=TRUE>>=
plot(E)
@ 

In this example, the command \verb!E <- envelope(finpines, Kest, nsim=39)!
generates 39 simulated point patterns according to a completely random process,
computes the estimated \Kfun{} for each simulated pattern, 
and finds the simulation envelopes
by identifying the pointwise minimum and maximum of the 39 simulated functions.
The result \texttt{E} is again an \obj\fv, but additionally belongs to the 
class \env, and contains additional information about how the
envelopes were computed. 

In the resulting plot, generated by the method \texttt{plot.envelope},
the region between the upper and lower
simulation envelopes is filled in grey shading. The solid black line
is the estimated \Kfun{} for the original \texttt{finpines} dataset,
and the dashed red line is the theoretical \Kfun{} for a completely
random pattern.

There is a lot of auxiliary information, displayed by \texttt{print.envelope}:
<<>>=
E
@ 

This vignette also explains how to plot, manipulate and create \objs\env.

\subsection{Why bother?}

Any self-respecting programmer would regard it as a 
trivial task to organise data in a data frame
and plot each column of data as a curve in a graph.
Although the task is trivial, it can be time-consuming,
it is prone to error, and it can take many attempts to get it 
exactly right. The authors of \spst\ developed the class \fv\ 
to make this job easier.

The class \fv{} is designed to
\begin{itemize}
\item 
  support \emph{multiple versions of a function},
  such as the different estimates of the \Kfun{} obtained using
  different edge corrections, the theoretical version of the \Kfun{}
  for a completely random process, the upper and lower simulation envelopes
  of the \Kfun, and so on. 
\item 
  do the \emph{``book-keeping''} about the different versions
  of the function, such as generating the mathematical labels 
  for use in a plot.
\item 
  support \emph{calculations} that will be applied automatically
  to all the versions of the function.
\item 
  support \emph{conversion} to other data types in base \R,
  such as data frames and functions.
\end{itemize}

For example, Besag's $L$ function is defined as 
$L(r) = \sqrt{K(r)/\pi}$. Since we have already computed the 
\Kfun{} in the example above, we can compute and plot the $L$-function
just by typing

<<>>=
L <- sqrt(K/pi)
@ 
<<L,fig=TRUE>>=
plot(L)
@ 

Several kinds of magic have happened here:
\begin{itemize}
\item The expression \texttt{sqrt(K/pi)}, 
  where \texttt{K} is an \obj\fv, has been evaluated
  automatically by calculating $\sqrt{K(r)/\pi}$ for each of the versions of the
  function stored in \texttt{K};
\item The internal data in the object \texttt{K}, which 
  provide mathematical labels for each version of the \Kfun,
  have been modified according to the algebraic operation 
  that was just performed;
\item The result has been saved as a new \obj\fv{} named \texttt{L};
\item The \texttt{plot} method has correctly displayed each version
  of the modified function using the modified mathematical labels, both
  on the vertical axis and in the legend box;
\item The \texttt{plot} method has \textbf{automatically computed the position
    of the legend box} to prevent it from overlapping the plotted curves;
\item The unit of length for the function argument has been
  correctly saved in the object \texttt{L} and 
  correctly reported on the horizontal axis label.
\end{itemize}

The class \env{} extends the class \fv{} to handle additional information
about how the envelopes were computed. The code supporting the class \env{}
performs many of the ``trivial'' but error-prone calculations involving
envelopes. An \obj\env{} can also contain the simulated data (the point patterns
and/or the summary functions) that were used to compute the envelopes, 
which makes it possible to re-use the simulated data to compute a different
version of the envelope. 

\newpage
\section{Plotting}
\label{S:plot.fv}

\subsection{Default plot}

If \texttt{f} is an object of class \class{fv},
the command \texttt{plot(f)} is dispatched to the method \fun{plot.fv}.
The default behaviour of \texttt{plot(f)} is to generate a plot
containing several curves, each representing a different
version of the same target function,
plotted against the distance argument $r$. 

<<eval=FALSE>>=
plot(Gest(finpines))
@ 
<<Gplot,fig=TRUE,echo=FALSE,results=hide>>=
aa <- plot(Gest(finpines))
@ 

Here \texttt{Gest} computes estimates of the nearest-neighbour
distance distribution function $G(r)$. The plot shows three
empirical estimates of $G(r)$ for the \texttt{finpines}
dataset, together with the `theoretical' 
curve $\pois G(r)$ expected for a completely random pattern,
all plotted against the distance argument $r$. 
The legend indicates the meaning of each curve. 
The main title identifies the object in \R\ that was plotted. 

The return value from \fun{plot.fv} is a data frame containing
more detailed information about the meaning of the curves. 
For the plot generated above, the return value is
<<eval=FALSE>>=
aa <- plot(Gest(finpines))
aa
@ 
<<echo=FALSE>>=
aa
@ 
Here \texttt{lty} and \texttt{col} are the graphics parameters
controlling the line type and line colour, and \texttt{label} is 
the mathematical notation for each edge-corrected estimate,
in the syntax recognised by \R{} graphics functions. 

The plot generated by \texttt{plot.fv} uses the base \R\ graphics system
(not \texttt{lattice} or \texttt{ggplot}). 
and is affected by graphics parameters
specified by \texttt{par()}.

\subsection{Modifying parameters of the default plot}

The default plot can easily be modified:
\begin{description}
\item[margin space:]
  To change the amount of white space around the plot,
  use \texttt{par('mar')}.
\item[main title:]
  use \texttt{main=""} to suppress the main title.
\item[legend:] 
  Set \texttt{legend=FALSE} to suppress the legend.
  Use the argument \texttt{legendargs} to modify the legend.
  The legend position is 
  automatically computed to avoid overlap with the plotted curves,
  but this can be overridden by \texttt{legendpos}. 
\item[range of values:] 
  Use \texttt{xlim} and \texttt{ylim} to specify the ranges
  of values on the $x$ and $y$ axes.
  \textbf{See the note below about the ``recommended range''.}
  Use \texttt{ylim.covers} to specify a numerical value or values that
  must be covered by the $y$ axis. For example, \texttt{ylim.covers=0}
  means that the $y$ axis will always include the origin.
\end{description}
For further information, see \texttt{help(plot.fv)}.

\subsection{Recommended range and recommended columns}

The default plot of an \fv\ object does not necessarily display
all the data that is contained in the object:
\begin{description}
\item[shorter range of distances:]
  the range of values of the distance argument $r$ 
  displayed in the default plot may be shorter than the 
  range of values actually contained in the data frame. 
\item[not all columns of data:] 
  the plot may not display all the columns of data contained in the data frame.
\end{description}

This happens because an \obj\fv\ contains ``recommendations'' 
about the range of distances that should be displayed,
and about the columns of data that should be shown.
These recommendations are based on standard statistical practice.
The recommendations are followed when the default plot is generated,
unless they are specifically overridden.

Consider this example:
<<>>=
G <- Gest(finpines)
G
@ 

The printout shows the range of values of \texttt{r} that are present 
in the table as the `\texttt{available range}'. It also gives a 
`\texttt{recommended range}' which is generally shorter than the
available range. \emph{The default plot of the object will only show the 
function values over the recommended range} and not over the full range of
values available. This is done so that the interesting detail
is clearly visible in the default plot. Values outside the recommended range 
may be unreliable due to increased variance or bias, depending on the
edge correction. To prevent this behaviour and use the full range
of function values available, set \texttt{clip.xlim=FALSE} in the 
plot command. Alternatively, specify the desired range of \texttt{r} values
using the argument \texttt{xlim} in the plot command.

The printout also says that the default plot formula is \verb! . ~ r !
where ``\verb!.!'' stands for \texttt{"km", "rs", "han", "theo"}.
This means that the default plot will display only the columns 
named \texttt{"km", "rs", "han"} and \texttt{"theo"} and will \textbf{not}
display the columns named \texttt{"hazard"} and \texttt{"theohaz"} which
are mentioned in the printout. This is consistent with the graphic shown
above. 

In this example, the column named \texttt{"hazard"} is an estimate
of the \emph{hazard rate} $h(r) = G'(r)/(1-G(r))$ of the nearest neighbour
distance function, rather than an estimate of $G(r)$ itself. 
The column named \texttt{"theohaz"} is the corresponding 
theoretical value of the hazard rate, expected 
if the point pattern is completely random.
It makes sense that the hazard rate $h(r)$ and distribution function $G(r)$
should not normally be plotted together.
Therefore when \texttt{Gest} is executed, it designates
\texttt{"km", "rs", "han", "theo"} as the ``recommended columns''
that should be displayed by default, and it stores this information
in the resulting object \texttt{G}. When \texttt{plot(G)} 
is executed, \texttt{plot.fv} uses this information to determine which
columns are to be plotted.

\subsection{Plot specified by a formula}

Different kinds of plots can be specified using a \texttt{formula}
as the second argument to \texttt{plot.fv}.
The left side of the formula represents what variables will
be plotted on the vertical ($y$) axis, and the right side determines the 
variable on the horizontal ($x$) axis.
For example, in the object
\texttt{K <- Kest(finpines)}, the column named \texttt{iso}
contains the values of the isotropic correction estimate. 
To plot the isotropic correction estimate against $r$, simply do
<<Kiso,fig=TRUE>>=
plot(K,  iso ~ r)
@ 

In \fun{plot.fv}, both sides of the plot formula are interpreted
as mathematical expressions, so that operators like
`\verb!+!', `\verb!-!', `\verb!*!', `\verb!/!'
have their usual meaning in arithmetic. 
The right-hand side of the formula can be any expression
that, when evaluated, yields a numeric vector, and the left-hand side is any
expression that evaluates to a vector or matrix of compatible
dimensions. 

If the left-hand side of the formula, when evaluated, yields a matrix, 
then each column of that
matrix is plotted against the specified $x$ variable as a separate curve.  
In particular the left-hand side of the formula may invoke the
function \fun{cbind} to indicate that several different curves
should be plotted. For example, to plot only the 
isotropic correction estimator and the theoretical curve:
<<Kit,fig=TRUE>>=
plot(K, cbind(iso, theo) ~ r)
@ 

Notice that, in this example, \texttt{plot.fv} is clever enough to recognise
that \texttt{iso} and \texttt{theo} are both versions of the \Kfun\ $K(r)$, 
and to decide that the appropriate label for the vertical axis is just $K(r)$.

The plot formula may also involve the names of constants like \texttt{pi},
standard functions like \texttt{sqrt}, and some special abbreviations listed
in Table~\ref{tab:fvnames}. 

\begin{table}[!h]
  \begin{tabular}{ll}
    \verb!.x! & argument of function \\
    \verb!.y! & best estimate of function \\
    \verb!.! & all recommended estimates of function \\
    \verb!.a! & all columns of function values \\
    \verb!.s! & upper and lower limits of shading
  \end{tabular}
    \caption{
      Recognised abbreviations for columns of an \class{fv} object.
    }
    \label{tab:fvnames}
\end{table}

The symbol \verb!.x! represents the function argument, usually \texttt{"r"}. 
The symbol \verb!.y! represents one of the columns of function values
which has been designated as the `best' estimate, for use by some other
commands in \spst.  
The symbol `\verb!.!' represents the `recommended' estimates.
The default plotting formula is \verb!. ~ .x!  indicating that
each of the recommended estimates will be plotted against
the function argument. The formula \verb!.y ~ .x! means that the
best estimate of the function will be plotted against the function argument.

To expand these abbreviations for a particular \fv\ object, 
use the function \texttt{fvnames}.
<<>>=
fvnames(K, ".y")
fvnames(K, ".")
@ 

A plot formula can be used to specify a transformation
that should be applied to the function values before they are displayed.
For example, to subtract the theoretical Poisson value
from each of the function estimates:
<<Ksubtheo,fig=TRUE>>=
plot(K, . - theo  ~ r)
@ 

Alternatively one could plot the function estimates \emph{against} the
Poisson value:
<<Ktheo,fig=TRUE>>=
plot(K, . ~ theo)
@ 

This plot has some theoretical support. 
In the discussion of Ripley's paper, Cox \cite{cox77discuss}
proposed that $\widehat K(r)$ should be plotted against $r^2$,
which is almost equivalent. We can follow Cox's recommendation
exactly:
<<Kcox,fig=TRUE>>=
plot(K, . ~ r^2)
@ 

The mathematical labels for the plot axes, and for the individual curves,
are constructed automatically by \spst\ from the plot formula. 
If the plot formula involves the names of external variables,
these will be rendered in Greek where possible. For example, to 
plot the average number of trees surrounding a typical tree in the
Swedish Pines data, 
<<Kswed,fig=TRUE>>=
lambda <- intensity(swedishpines)
plot(K, lambda * . ~ r)
@ 

Here we use the name \texttt{lambda} 
so that it will be rendered as the Greek letter $\lambda$ in
the graphics: the $y$-axis will be labelled $\lambda K(r)$. 

\section{Calculating with \fv\ objects}

\subsection{Arithmetic and mathematical operators}

Arithmetic and mathematical operations on \objs\fv\ 
can be performed by simply writing the arithmetic expression
involving the name of the object. The following are valid:
<<eval=FALSE>>=
K <- Kest(cells)
K/pi
sqrt(K/pi)
@ 

These inline calculations are performed by the operators 
\texttt{Ops.fv} and \texttt{Math.fv}.
The operation is applied to each column of \emph{function values};
the function argument \texttt{r} will not be affected.
The result is another \obj\fv\ with the same number of columns,
with the same column names, but with appropriately adjusted 
auxiliary information.

The expression can involve a command which returns an \obj\fv:
<<eval=FALSE>>=
asin(sqrt(1-Gest(cells)))
Gest(cells) - Gest(redwood)
@ 

The auxiliary information will be slightly less elegant in this case.

If there are several \fv\ objects in the expression, they 
should be `compatible' in the sense that they have the same column names, 
and the same vector of $r$ values. However, \texttt{eval.fv} will
attempt to reconcile incompatible objects. 
(The \spst\ generic function \fun{compatible} determines whether two or more
objects are compatible, and the generic function \fun{harmonise}
makes them compatible, if possible.)

These arithmetic and mathematical operations are applied only to the 
\emph{recommended} columns of function values
identified by \texttt{fvnames(, ".")}. 

\subsection{Other vectorised operations}

Functions such as \texttt{pmax} and \texttt{cumsum} apply to vector data,
but are not recognised as arithmetic or mathematical operators, so they are
not covered by \texttt{Ops.fv} and \texttt{Math.fv}. 

For expressions involving \texttt{pmax} and \texttt{cumsum} (or indeed
any algebraic expression whatsoever), 
use the command \texttt{eval.fv} to perform the
calculation simultaneously for each column of function values:
<<eval=FALSE>>=
Kpos <- eval.fv(pmax(0, K))
@ 
The result \texttt{Kpos} is another \obj\fv\
in which the function values are all non-negative.

The first argument of \texttt{eval.fv} should be an expression
involving the \textbf{name} of the \obj\fv, or the \textbf{names}
of several \objs\fv:
<<eval=FALSE>>=
Kcel <- Kest(cells)
Kred <- Kest(redwood)
Km <- eval.fv(pmax(Kcel, Kred))
@ 

By default, the calculation is only applied to the 
\emph{recommended} columns of function values
identified by \texttt{fvnames(, ".")}.
This may be overridden by setting \texttt{dotonly=FALSE} in the call
to \texttt{eval.fv}.

The computations of \texttt{Ops.fv} and \texttt{Math.fv} are implemented
using \texttt{eval.fv} but there may be slight 
differences in the handling of the
auxiliary information. 

\subsection{Calculations involving specific columns}
\label{p:with.fv}

To manipulate or combine one or more columns of data in an \class{fv} object,
it is typically easiest to use \fun{with.fv}, 
a method for the generic \fun{with}. 
This behaves in a very similar way to \texttt{with.data.frame}.
For example:
<<>>= 
Kr <- Kest(redwood)
y <- with(Kr, iso - theo)
x <- with(Kr, r)
@ 
The results \texttt{x} and \texttt{y} are numeric
vectors, where \texttt{x} contains the values of the distance
argument $r$, and \texttt{y} contains the difference between
the columns \texttt{iso} (isotropic correction estimate) and
\texttt{theo} (theoretical value for CSR) for the \Kfun{}
estimate of the redwood seedlings data.  For this to work, we
have to know that \texttt{Kr} contains columns named \texttt{r},
\texttt{iso} and \texttt{theo}.  Printing
the object will reveal this information, as would typing
\texttt{names(Kr)} or \texttt{colnames(Kr)}.

The general syntax is \texttt{with(X, expr)} where \texttt{X}
is an \class{fv} object and \texttt{expr} can be any expression
involving the names of columns of \texttt{X}. The expression
can include functions, so long as they are capable of operating
on numeric vectors.  The expression can also involve the abbreviations
listed in Table~\ref{tab:fvnames}.
Thus: \verb!Kcen <- with(Kr, . - theo)! subtracts the
`theoretical' value from all the available edge correction
estimates.  In this case the result \texttt{Kcen} is an
\class{fv} object.   You can also get a result which is a
vector or single number:
<<>>=
with(Kr, max(abs(iso-theo)))
@ 
To subtract the theoretical expected value from all the estimated
function values:
<<>>=
Kadjusted <- with(K, . - theo)
@ 
Here \texttt{Kadjusted} is another \obj\fv.

\subsection{Extracting data}

An \obj\fv\ is essentially a data frame with additional attributes.
It contains the values of the desired function (such as $K(r)$) 
at a finely spaced grid of values of the function argument $r$.

The data frame can be extracted (and the additional attributes
removed) using \texttt{as.data.frame.fv}:
<<>>=
df <- as.data.frame(K)
@ 

A single column of values can be extracted using the \verb!$! 
operator in the usual way: \verb!K$iso! %$
would extract a vector containing the isotropic correction estimates of $K(r)$. 

The subset extraction operator `\verb![!' has a method  %]
for \class{fv} objects. This always returns another 
\class{fv} object, so it will refuse to remove the column 
containing values of the function argument \texttt{r}, for example.
To override this refusal, 
convert the object to a data frame using \fun{as.data.frame} 
and then use `\verb![!': % ]
the result will be a data frame or a vector.

Commands designed for data frames often work for \class{fv} objects as well. 
The functions \texttt{head} and \texttt{tail} extract the top (first few rows)
and bottom (last few rows) of a data frame. They also work on \class{fv}
objects: the result is a new \class{fv} object containing the 
function values for a short interval of $r$ values 
at the beginning or end of the range. The function \texttt{subset} 
selects designated subsets of a data frame using an elegant syntax
and this also works on \class{fv} objects. To restrict \texttt{K}
to the range $r \le 0.1$ and remove the border correction,
<<>>=
Ko <- subset(K, r < 0.1, select= -border)
@ 

\subsection{Converting to a true function}

An \obj\fv\ is meant to represent a function, but it contains only sample values
of the function at a grid of values of the function argument. 
The table of function values can also be converted to a true function
in the \R{} language using \fun{as.function}. This makes it easy
to evaluate the function at any desired distance $r$.
<<>>=
Ks <- Kest(swedishpines)
kfun <- as.function(Ks)
kfun(9)
@ 
By default, the result \texttt{kfun} is a function in \R, 
with a single argument 
\texttt{r} (or whatever the original function argument was called).
The new function accepts numeric values or numeric vectors of distance values, 
and returns the values of the `best' estimate of the function, 
interpolated linearly between entries in the table. 

If one of the other function estimates is required, 
use the argument \texttt{value} to \fun{as.function} to select it. 
Several estimates can be chosen:
<<>>=
kf <- as.function(Ks, value=".")
kf(9)
kf(9, "trans")
@ 
  kfun(0.1)
@ 

\subsection{Special operations}
\label{S:manip.fv}

An \class{fv} object can be manipulated using the operations
listed in Table~\ref{tab:fvmethods}. 

\begin{table}[!h]
\begin{tabular}[c]{ll}
  \texttt{f} & print a description \\
  \texttt{print(f)} & print a description \\
  \texttt{plot(f)} & plot the function estimates \\
  \texttt{as.data.frame(f)} & strip extra information (returns a data frame) \\
  \verb!f$iso! & extract column named \texttt{iso} (returns a numeric vector) \\
  \verb!f[i,j]! & extract subset (returns an \class{fv} object) \\
  \verb!subset(f, ...)! & extract subset (returns an \class{fv} object) \\
  \texttt{with(f, expr)} & perform calculations with columns of data frame\\
  \texttt{eval.fv(expr)} & perform calculations with several \class{fv} objects \\
  \verb!cbind(f1, f2, ...)! & combine \class{fv} objects \texttt{f1, f2, ...} \\
  \texttt{bind.fv(f, d)} & combine an \class{fv} object \texttt{f} and data frame \texttt{d} \\
  \verb!collapse.fv(f1, f2, ...)! & 
      combine several redundant \class{fv} objects  \\
  \verb!compatible(f1, f2, ...)! & 
  check whether \class{fv} objects are compatible  \\
  \verb!harmonise(f1, f2, ...)! & 
  make \class{fv} objects compatible  \\
  \texttt{min(f)}, \texttt{max(f)}, \texttt{range(f)} & 
                range of function values \\
  \texttt{Smooth(f)} & apply smoothing to function values \\
  \texttt{deriv(f)} & derivative of function\\
  \texttt{stieltjes(g,f)} & compute Stieltjes integral with respect to \texttt{f} \\
  \texttt{as.function(f)} & convert to a function
\end{tabular}
\caption{Operations for manipulating an \class{fv} object \code{f}.}
\label{tab:fvmethods}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structure of \objsfvenv}

This section explains the information contained in \objsfvenv.

\subsection{Advice}

We strongly discourage the user from unpacking the internal
contents of \objs\fv{} and manipulating the contents directly.
Instead, we recommend using the functions that are available in \spst{} 
for handling these objects. 

Although it is easy to extract the internal data contained in an object
in \R, the structure of \objs\fv\ is idiosyncratic, and the internal format
is variable. Looking at one example of an \obj\fv\ will not tell you how
it all works. This is because there are many cases to handle,
and many quirks in the formatting of algebraic expressions in \R.

Using the functions provided in \spst\ is also more efficient 
than extracting data yourself, because it avoids creating multiple 
copies of the data.

Most of all, \textbf{do not change the internal contents of \objs\fv}.
This can easily violate the internal format and cause errors.
Use the functions supplied for handling these objects.


\subsection{Objects of class \fv}

Objects of class \fv\ are returned by many commands in the 
\spst\ packages. Usually these objects are obtained by
analysing a spatial point pattern dataset.
There are also functions to create such objects from raw data.

An \obj\fv{} is essentially a data frame with
additional attributes containing auxiliary information.

\subsubsection*{Data frame structure}

The first column of the data frame contains values of the 
function argument. These values are arranged in increasing order,
are usually evenly-spaced, and usually start from zero. The first
column usually (but not always) has the column name \texttt{r}.

Subsequent columns of the data frame contain the values of
different versions of the summary function, corresponding to the
values of the function argument. These columns may have any column names.
These versions of the function may be referred to by their column names
when plotting and manipulating the object.

<<>>=
G <- Gest(finpines)
df <- as.data.frame(G)
head(df)
@ 

In this example, the object \texttt{G} contains estimates of
the nearest-neighbour distance distribution function $G(r)$
for the \texttt{finpines} dataset. For the distance
value $r = $ \Sexpr{df[3, "r"]} metres, the estimate of $G(r)$ 
using the \texttt{han} method is \Sexpr{df[3, "han"]}. 

Columns of data can be extracted using the data frame structure.
To extract the sequence of \texttt{r} values, 
use \verb!df$r! or \verb!G$r!. To extract the corresponding values of
\texttt{han}, use \verb!df$han! or \verb!G$han!. 

\subsubsection*{Auxiliary information}

In the example above,
to find out what the column \texttt{han} means, we need the
auxiliary information stored in the object \texttt{G}. 
This can be printed out directly in readable form:
<<>>=
G
@ 
Thus, \texttt{han} refers to the estimate of $G(r)$ using Hanisch's method.

The auxiliary information is stored in attributes
of the object. The full list of attributes is as follows:

\begin{tabular}{lll}
\texttt{argu} & character(1) & Name of function argument (usually \texttt{"r"}) \\
\texttt{valu} & character(1) & Name of preferred function value \\
\texttt{ylab} & language  & Mathematical expression for function (for vertical axis of plot) \\
\texttt{yexp} & language  & Mathematical expression for function (in algebra) \\
\texttt{fmla} & character(1) & Default plotting formula \\
\texttt{alim} & numeric(2) & Recommended range of function argument \\
\texttt{labl} & character($m$) & Mathematical labels for each column\\
\texttt{desc} & character($m$) & Text descriptions of each column\\
\texttt{units} & unitname & Unit of length (for function argument) \\
\texttt{fname} & character(1 or 2) & Symbol for function only \\
\texttt{dotnames} & character($k \le m$) & Column names of all recommended versions \\
\texttt{shade} & character(0 or 2) & Column names of limits of grey shading\\
\end{tabular}

\code{argu} is the name of the column of the data frame
that contains the values of the function argument
(typically \code{argu="r"} but this is not compulsory).

\code{valu} specifies the name of another column
that contains the `recommended' estimate of the function.
It will be used to provide function values in those situations where
a single column of data is required. For example,
\code{envelope} computes its simulation envelopes
using the recommended value of the summary function.

\code{fmla} specifies the default plotting behaviour,
as explained in Section~\ref{S:plot.fv}. It is a character string
that can be converted to a \texttt{formula} in the \R\ language.

\code{alim} specifies the recommended range of the
function argument. It is a numeric vector of length 2.
This is used in situations where statistical
theory or statistical practice indicates that the computed
estimates of the function are not trustworthy outside a certain
range of values of the function argument. By default,
\code{plot.fv} will restrict the plot to this range.

\code{fname} gives the name of the function itself.
For example, the \Kfun{}  would have \code{fname="K"}.
It is either a character string, or a vector of two character strings,
where the second element is interpreted as a subscript.
For example, the inhomogeneous \Kfun{} computed by \code{Kinhom}
has \code{fname=c("K", "inhom")}.
  
\code{ylab} is a mathematical expression
for the function value, used when printing a description of the
function. It is an \R{} language object. 
For example the \Kfun's mathematical name $K(r)$ is rendered
by \code{ylab=quote(K(r))}. 

\code{yexp} is another mathematical expression
for the function value, used for annotating axes in a plot. 

\code{labl} is a character vector specifying plot labels
for each column of the data frame. These labels will appear on the
plot axes (in non-default plots), legends and printed output.
Entries in \code{labl}
may contain the string \code{"\%s"} which will be replaced
by \code{fname}. 

\code{desc} is a character vector containing intelligible
explanations of each column of the data frame. Entries in
\code{desc} may contain the string \code{"\%s"} which will be replaced
by \code{ylab}. 



\subsection{Envelope objects}

Objects of class \env\ are returned by the \texttt{envelope} command
only.

\subsubsection{Structure}

An \obj\env{} is an \obj\fv{} with additional auxiliary information:
\begin{itemize}
\item 
  the names of two of the columns of function values,
  designated as the upper and lower simulation envelopes of the function,
  saved in \texttt{attr(, "shade")} and retrievable as 
  \texttt{fvnames(, .s)}
\item 
  details of how the envelopes were computed,
  saved in \texttt{attr(, "einfo")}
\item 
  optionally, the simulated point patterns used to compute the envelopes,
  saved in \texttt{attr(, "simpatterns")}
\item 
  optionally, the simulated summary functions
  (the summary functions computed for the simulated point patterns)
  used to compute the envelopes,
  saved in \texttt{attr(, "simfuns")}
\end{itemize}

Objects of class \env\ inherit the class \fv, so they can be manipulated
using methods for class \fv, but there are extra methods for the
special class \env. 

\subsubsection{The \texttt{einfo} list}

Additional attribute \texttt{einfo} is a list of:

\begin{tabular}{lll}
  \texttt{call} & character(1) & original function call \\
  \texttt{Yname} & character(1) & name of original dataset \\
  \texttt{valname} & character(1) & column name of function values used\\
  \texttt{csr} & logical(1) & \texttt{TRUE} if simulations based on CSR \\
  \texttt{csr.theo} & logical (1) & see below\\
  \texttt{use.theory} & logical (1) & see below\\
  \texttt{pois} & logical(1) & \texttt{TRUE} if simulations 
                               are Poisson process\\
  \texttt{simtype} & character(1) & Type of simulation (see below) \\
  \texttt{constraints} & character(1) & Additional information (see below) \\
  \texttt{nrank} & integer(1) & Rank of envelopes \\
  \texttt{nsim} & integer(1) & Number of simulations for envelope \\
  \texttt{Nsim} & integer(1) & Total number of simulations\\
  \texttt{global} & logical(1) & \texttt{TRUE} if global envelopes\\
  \texttt{ginterval} & numeric(0 or 2) & Domain of function argument for global envelopes \\
  \texttt{dual} & logical(1) & \texttt{TRUE} if two sets of simulations performed\\
  \texttt{nsim2} & integer(1) & Number of simulations in second set \\
  \texttt{VARIANCE} & logical(1) & \texttt{TRUE} if limits are based on standard deviation \\
  \texttt{nSD} & numeric(1) & Number of standard deviations defining limits \\
  \texttt{alternative} & character(1) & \texttt{two.sided}, \texttt{less} or \texttt{greater} \\
  \texttt{scale} & \texttt{NULL} or function & Scaling function for function argument \\
  \texttt{clamp} & logical(1) & \texttt{TRUE} if one-sided deviations must be positive \\
  \texttt{use.weights} & logical(1) & \texttt{TRUE} if sample mean is weighted\\
  \texttt{do.pwrong} & logical(1) & \texttt{TRUE} if ``wrong $p$-value'' should be calculated \\
  \texttt{gaveup} &  logical(1) & \texttt{TRUE} if simulations terminated early
\end{tabular}

\section{Creating \fv\ objects from raw data}

\begin{itemize}
\item command \texttt{fv}
\item \texttt{as.fv}
\item helper commands 
  \texttt{compileK}, \texttt{compilepcf}, \texttt{compileCDF}
  for specific types of functions
\end{itemize}

\subsection{The creator function \fun{fv}}

  The low-level function \code{fv} is used to create an object of
  class \code{"fv"} from raw numerical data.

<<>>=
names(formals(fv))
@ 
  The data frame \code{x} contains the numerical data.
  It should have one column
  (typically but not necessarily named \code{"r"})
  giving the values of the function argument for which
  the function has been evaluated; and at least one other column,
  containing the corresponding values of the function.

  Typically there is more than one column of function values.
  These columns typically give the values of different versions or estimates
  of the same function,
  for example, different estimates of the \Kfun{}  
  obtained using different edge corrections.
  However they may also contain the values of related functions
  such as the derivative or hazard rate.

  \code{argu} specifies the name of the column of
  \code{x} that contains the values of the function argument
  (typically \code{argu="r"} but this is not compulsory).

  \code{valu} specifies the name of another column
  that contains the `recommended' estimate of the function.
  It will be used to provide function values in those situations where
  a single column of data is required. For example,
  \code{envelope} computes its simulation envelopes
  using the recommended value of the summary function.

  \code{fmla} specifies the default plotting behaviour.
  It should be a formula, or a string that can be converted to a
  formula. Variables in the formula are names of columns of \code{x}.
  See \code{plot.fv} for the interpretation of this
  formula.

  \code{alim} specifies the recommended range of the
  function argument. This is used in situations where statistical
  theory or statistical practice indicates that the computed
  estimates of the function are not trustworthy outside a certain
  range of values of the function argument. By default,
  \code{plot.fv} will restrict the plot to this range.

  \code{fname} is a string giving the name of the function itself.
  For example, the \Kfun{}  would have \code{fname="K"}.
  
  \code{ylab} is a mathematical expression
  for the function value, used when labelling an axis
  of the plot, or when printing a description of the
  function. It should be an \R{} language object. 
  For example the \Kfun's mathematical name $K(r)$ is rendered
  by \code{ylab=quote(K(r))}. 

  If \code{yexp} is present, then \code{ylab} will be
  used only for printing, and \code{yexp} will be used for
  annotating axes in a plot. (Otherwise \code{yexp} defaults to \code{ylab}).
  For example the cross-type \Kfun{}  
  $K_{1,2}(r)$ is rendered by something like
  \code{ylab=quote(Kcross[1,2](r))}
  and 
  \code{yexp=quote(Kcross[list(1,2)](r))}
  to get the most satisfactory behaviour.

  (A useful tip: use \code{substitute} instead of
  \code{quote} to insert values of variables into an expression,
  e.g. \code{substitute(Kcross[i,j](r), list(i=42,j=97))}
  yields the same as \code{quote(Kcross[42, 97](r))}.)

  \code{labl} is a character vector specifying plot labels
  for each column of \code{x}. These labels will appear on the
  plot axes (in non-default plots), legends and printed output.
  Entries in \code{labl}
  may contain the string \code{"\%s"} which will be replaced
  by \code{fname}. For example the border-corrected estimate
  of the \Kfun{}  has label \code{"\%s[bord](r)"} which
  becomes \code{"K[bord](r)"}.

  \code{desc} is a character vector containing intelligible
  explanations of each column of \code{x}. Entries in
  \code{desc} may contain the string \code{"\%s"} which will be replaced
  by \code{ylab}. For example the border correction estimate of the
  \Kfun{}  has description \code{"border correction estimate of \%s"}.

  \textbf{Explain} \texttt{unitname}
  
\subsection{as.fv}

\subsection{compileK}

\section{Manipulating \fv\ objects}

\begin{itemize}
\item \verb![.fv!, \verb![<-.fv!
\item \texttt{subset.fv}
\item \texttt{bind.fv}, \texttt{cbind.fv}
  \begin{quote}
    Use \code{\link{cbind.fv}} to combine several \code{"fv"} objects.
    Use \code{\link{bind.fv}} to glue additional columns onto an existing
    \code{"fv"} object.
  \end{quote}
\item \texttt{harmonise}
\item \texttt{collapse}
\item \texttt{reconcilefv}
\end{itemize}

\section{Editing the auxiliary information in \fv\ objects}

\subsection{List of functions}

\begin{itemize}
\item \texttt{rebadge.fv}
\item \texttt{rebadge.as.crossfun}, \texttt{rebadge.as.dotfun}
\item \texttt{fvnames}, \verb!fvnames<-!
\item \texttt{fvlabels}, \verb!fvlabels<-!
\item \texttt{names.fv}, \verb!names<-.fv!
\item \texttt{makefvlabel}
\item \texttt{tweak.fv.entry}
\item \texttt{prefixfv}
\end{itemize}

\section{Pooling several function estimates}

\begin{itemize}
\item \texttt{ratfv}
\item \texttt{bind.ratfv}
\item \texttt{conform.ratfv}
\item \texttt{pool.fv}
\end{itemize}


\section{Text from the book, to be incorporated}

\subsubsection*{Envelopes}

The \spst\ function \fun{envelope} computes simulation envelopes.
The right panel of \figref{F:ptwiseEnvelopes} was generated by the
commands
<<eval=FALSE>>=
E <- envelope(swp, Kest, nsim=39, fix.n=TRUE)
plot(E)
@ 
The result of \fun{envelope} is an object of class \class{envelope}
which also belongs to the class \class{fv}. 
It can be plotted, printed, and manipulated
using the tools for \class{fv} objects described in \secref{S:fv}.
See Table~\ref{tab:fvmethods} on page~\pageref{tab:fvmethods}.
The print method gives a lot of detail:
<<>>=
E
@ 

\subsubsection*{Envelopes}

The \spst\ function \fun{envelope} performs the
calculations required for envelopes. It computes the 
summary function for a point pattern dataset, generates
simulated point patterns, computes the summary functions for the
simulated patterns, and computes the envelopes of these summary 
functions. 
The result is an object of class \class{envelope} and \class{fv}
which can be printed and plotted and manipulated
using the tools for \class{fv} objects described in \secref{S:fv}.
(See Table~\ref{tab:fvmethods} on page~\pageref{tab:fvmethods}.)
The print method gives a lot of detail:
For example,  \figref{F:envel.ex} was generated by the commands
<<eval=FALSE>>=
plot(envelope(redwood, Lest, nsim=39))
plot(envelope(redwood, Lest, nsim=39, global=TRUE))
@ 

<<echo=FALSE,results=hide>>=
EP <- envelope(redwood, Lest, nsim=39, savefuns=TRUE)
EG <- envelope(EP, global=TRUE)
@ 
\begin{figure}[!htb]
  \centering
<<fig=TRUE,echo=FALSE,results=hide>>=
par(mfrow=c(1,2))
plot(EP, main="", legend=FALSE)
plot(EG, main="", legend=FALSE)
@   
  \caption{Examples of the \fun{envelope} command.
    Pointwise (\emph{Left}) and global (\emph{Right})
    envelopes of Besag's \Lfun\ based on 39 simulations
    of CSR, and observed \Lfun\ for the \code{redwood} data.
  }
  \label{F:envel.ex}
\end{figure}

The function \fun{envelope} is generic, with methods for class
\class{ppp}, \class{ppm}, and several other classes.  If \texttt{X}
is a point pattern, then by default \texttt{envelope(X, ...)}
constructs pointwise envelopes for the null hypothesis of CSR.
If \texttt{M} is a fitted point process model, then by default
\texttt{envelope(M, ...)} constructs pointwise envelopes
for the null hypothesis represented by the model \texttt{M}.
The default behaviour is to construct pointwise envelopes from the
\Kfun{}s of 99 simulations.  Different summary functions, 
different types of envelopes,
different null hypotheses, different alternative hypotheses, and
different simulation procedures are selected using additional
arguments listed in Table~\ref{tab:envelope.args}.
\begin{table}[!htb]
  \centering
  \begin{tabular}{lll}
    \textsc{Argument} & \textsc{Default} & \textsc{Meaning} \\ \hline
    \texttt{Y} & & point pattern data, or fitted model \\
    \texttt{fun} & \texttt{Kest} & summary function \\
    \texttt{nsim} & 99 & number of simulations $m$ for test \\
    \texttt{nrank} & 1 & rank for statistical significance \\
    \texttt{global} & \texttt{FALSE} & global envelopes \\
    \texttt{VARIANCE} & \texttt{FALSE} & envelopes based on sample variance \\
    \texttt{simulate} & & procedure for generating simulated patterns \\
    \texttt{alternative} & \texttt{two.sided} &  alternative hypothesis \\
    \texttt{fix.n} & \texttt{FALSE} &  fix number of points \\
    \texttt{fix.marks} & \texttt{FALSE} & fix number of points of each type \\
    \texttt{correction} & & edge correction for summary function  \\
    \texttt{transform} &  & transformation of summary function \\
    \texttt{ginterval} &  & range of distance values for global envelopes\\
    \texttt{nsim2} & \texttt{nsim} & number of simulations to estimate mean \\
    \texttt{savepatterns} & \texttt{FALSE} & store point patterns\\
    \texttt{savefuns} & \texttt{FALSE} & store summary functions 
  \end{tabular}
  \caption{Common arguments for \fun{envelope}.}
  \label{tab:envelope.args}
\end{table}

\subsection{Envelopes based on a set of point patterns}

Envelopes can also be computed from a user-supplied list of 
point patterns, instead of the simulated point patterns
generated by a chosen simulation procedure. The argument 
\texttt{simulate} can be a list of point patterns:
<<eval=FALSE>>=
Xlist <- runifpoint(42, nsim=99)
envelope(cells, Kest, nsim=99, simulate=Xlist)
@ 
The argument \texttt{simulate} can also be an \class{envelope} object.
This improves efficiency and consistency if, for example, we are going to 
calculate the envelopes of several different summary statistics. 
<<eval=FALSE>>=
EK <- envelope(cells, Kest, nsim=99, savepatterns=TRUE)
Ep <- envelope(cells, pcf,  nsim=99, simulate=EK)
@ 
In the first call to \texttt{envelope}, the argument 
\texttt{savepatterns=TRUE} indicates that we want to save the simulated
point patterns. These are stored in the object \texttt{EK}. Then in the second
call to \texttt{envelope}, the simulated patterns are extracted from
\texttt{EK} and used to compute the envelopes of the pair correlation function.

The method \texttt{envelope.envelope} allows envelope calculations
to be based on an existing \class{envelope} object. The previous example
could have been done by typing
<<eval=FALSE>>=
EK <- envelope(cells, Kest, nsim=99, savepatterns=TRUE)
Ep <- envelope(EK, pcf)
@ 

\subsection{Types of envelopes in \spst}

\subsubsection{Pointwise envelopes}

By default, \fun{envelope} computes pointwise envelopes of the
summary function. The argument \texttt{nsim} controls the number $m$ of
simulated point patterns. The argument \texttt{nrank} specifies
the rank $k$ of the critical value amongst the simulated values:
the envelopes are based on the $k$th largest and $k$th smallest simulated
values. The default is $k=1$, meaning that the minimum and maximum
simulated values will be used. For a two-sided test, the 
significance level is $2k/(m+1)$.

\subsubsection{Simultaneous envelopes}

To obtain simultaneous (global) envelopes, set \texttt{global=TRUE}:
<<eval=FALSE>>=
envelope(redwood, Lest, global=TRUE)
@ 
The significance level is $k/(m+1) = 1/(1+99) = 0.01$.

As noted in \secref{S:globalEnvelopes}, the outcome of the test
is affected by transforming the summary function.
In order to achieve the maximum power of the test,
it is usually recommended to apply a 
\emph{variance-stabilising} transformation to the summary function,
that is, a transformation $H(r) = f(S(r))$ such that the variance of $H(r)$
\label{pg:var.stab.trans}
is approximately constant as a function of $r$. 
The global measure of deviation \eqref{e:MAD} treats
all fluctuations of the summary function $S$ equally; 
this could be inappropriate if fluctuations of
$S(r)$ at some distance $r$ are more informative than at other distances.
After a variance-stabilising transformation, 
fluctuations in the summary function at different distances $r$
have equal scale, so can be treated equally.

An approximate variance-stabilising transformation for the \Kfun{}  
is the square root, as explained on page~\pageref{e:Lfun}.
Indeed this was one of the motivations for
Besag's \cite{besa77d} original proposal of the \Lfun,
$L(r) = \sqrt{K(r)/\pi}$. Thus we would typically use \texttt{Lest}
rather than \texttt{Kest} for global envelopes.

For the summary functions $F$ and $G$, an approximate
variance-stabilising transformation is Fisher's arcsine
transformation $f(x) = \arcsin \sqrt x$ 
as explained on page~\pageref{e:FisherArcsin}. Rather than writing a new
function for the variance-stabilised versions of \texttt{Fest}
and \texttt{Gest}, we can specify the transformation using the
argument \texttt{transform}:
<<eval=FALSE>>=
fisher <- function(x) { asin(sqrt(x)) }
envelope(redwood, Fest, global=TRUE, 
         transform=expression(fisher(.)))
@ 
To allow very flexible specification of the transformation, 
\fun{envelope} uses \fun{with.fv} to evaluate the 
\texttt{transform} expression. In the syntax of \fun{with.fv},
the symbol `\texttt{.}' represents the function value,
in this case the value of the estimate $\widehat F(r)$. 
  
\subsubsection{Envelopes based on sample mean \& variance}

Envelopes can be constructed using the sample mean and sample
variance of the simulations. By default the envelopes consist of the
sample mean plus or minus 2 times the sample standard deviation.
This is useful for understanding the variability of the summary
function. Be aware that these envelopes do not have the same
significance interpretation as the global envelopes produced
from ranking absolute deviations.

<<eval=FALSE>>=
envelope(cells, Kest, nsim=100, VARIANCE=TRUE)
@ 

\subsubsection{One-sided envelopes}

In \texttt{envelope} methods, the 
argument \texttt{alternative} is a 
    character string determining whether the envelopes correspond
    to a two-sided test (\texttt{alternative="two.sided"}, the default)
    or a one-sided test with a lower critical boundary
    (\texttt{alternative="less"}) or a one-sided test
    with an upper critical boundary (\texttt{alternative="greater"}).

<<cache=TRUE,echo=FALSE,results=hide>>=
a1 <- envelope(cells, Lest, nsim=19, alternative="less")
a2 <- envelope(cells, Lest, nsim=19, alternative="greater")
@     
\begin{figure}[!htb]
  \centering
<<fig=TRUE,echo=FALSE,results=hide>>=
plot(anylist(a1, a2), 
     main="", main.panel="", equal.scales=TRUE,
     mar.panel=c(4,4,1,1), hsep=1, legend=FALSE)
@   
  \caption{One-sided envelopes.
    Grey shading shows the pointwise acceptance region for
    a one-sided test of CSR against the alternative of
    regularity (\emph{Left}) or clustering (\emph{Right})
    based on the \Lfun{}s of 19 simulations of CSR.
    Thick line shows empirical \Lfun\ for the \code{cells} data.
  }
  \label{F:onesided}
\end{figure}

\subsection{Re-using envelope data}

\subsubsection*{Computing new envelopes}

The method \texttt{envelope.envelope} allows new \fun{envelope} commands to
be applied to a previously computed \class{envelope} object,
provided it contains the necessary data.

In the original call to \fun{envelope}, if the argument
\texttt{savepatterns=TRUE} was given, the resulting \class{envelope}
object contains all the simulated point patterns.  Alternatively
if the argument \texttt{savefuns=TRUE} was given, the resulting
object contains the individual summary functions for each of the
simulated patterns.  This information is not saved, by default,
for efficiency's sake.

Envelopes created with \texttt{savepatterns=TRUE} allow any kind of
new envelopes to be computed using the same simulated point patterns:
<<eval=FALSE>>=
E1 <- envelope(redwood, Kest, savepatterns=TRUE)
E2 <- envelope(E1, Gest, global=TRUE, 
               transform=expression(fisher(.)))
@ 

Envelopes created with \texttt{savefuns=TRUE} allow 
the user to switch between pointwise and global envelopes
of the same summary function, to apply different transformations
of the summary function, and to change some parameters:
<<eval=FALSE>>=
A1 <- envelope(redwood, Kest, nsim=39, savefuns=TRUE)
A2 <- envelope(A1, global=TRUE, nsim=19, 
               transform=expression(sqrt(./pi)))
@ 

\subsubsection*{Pooling several envelopes}

It is also possible to combine the simulation data
from several envelope objects 
and to compute envelopes based on the combined data.
This is done using \fun{pool.envelope}, a method for
the \spst\ generic \fun{pool}.
The envelopes must be compatible,
in that they are envelopes for the same function,
and were computed using the same options. The
individual summary functions must have been saved.
<<eval=FALSE>>=
E1 <- envelope(cells, Kest, nsim=10, savefuns=TRUE)
E2 <- envelope(cells, Kest, nsim=20, savefuns=TRUE)
E <- pool(E1, E2)
@ 
The method for pooling summary functions is detailed in \secref{S:poolK}.



\begin{thebibliography}{1}
\bibitem{baddrubaturn15}
A. Baddeley, E. Rubak, and R. Turner.
\newblock {\em Spatial Point Patterns: Methodology and Applications with {{R}}}.
\newblock Chapman \& Hall/CRC Press, 2015.
\bibitem{besa77d}
J.E. Besag. 
\newblock Contribution to the discussion of the paper by Ripley (1977).
\newblock \emph{Journal of the Royal Statistical Society, Series B}
\textbf{39} (1977) 193--195.
\bibitem{cox77discuss}
D.R. Cox.
\newblock Contribution to the discussion of the paper by Ripley (1977).
\newblock \emph{Journal of the Royal Statistical Society, Series B}
\textbf{39} (1977) 206.
\end{thebibliography}

\end{document}
